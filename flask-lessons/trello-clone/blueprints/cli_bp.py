from flask import Blueprint
from setup import db, bcrypt
from models.user import User
from models.card import Card
from datetime import date

#to use commands in this blueprint need to pass name of blueprint (db) ie: flask db create
db_commands = Blueprint("db", __name__)

# Create tables - make a terminal command - use flask db_create to run
@db_commands.cli.command('create')
def db_create():
    db.drop_all()
    db.create_all()
    print('created tables')

# Seed database
@db_commands.cli.command('seed')
def db_seed():
    # card1 = Card(
    #     title='Start the project',
    #     description = 'Stage1 - Create ERD',
    #     date_created = date.today()
    #     )
    # # Add to session queue
    # db.session.add(card1)

    # card2 = Card(
    #     title='Eat a pie',
    #     description = 'Stage2 - have a snack',
    #     date_created = date.today()
    #     )
    # # Add to session queue
    # db.session.add(card2)    

    # card3 = Card(
    # title='Marshmallow',
    # description = 'Stage3 - have another snack',
    # date_created = date.today()
    # )
    # # Add to session queue
    # db.session.add(card3)    

    users = [
        User(
            email="admin@spam.com",
            password=bcrypt.generate_password_hash("spinynorman").decode('utf8'),
            is_admin=True
        ),
        User(
            name="John Cleese",
            email="cleese@spam.com",
            password=bcrypt.generate_password_hash("tisbutascratch").decode('utf-8')
        )
    ]

    cards = [
        Card(
            title='Start the project',
            description = 'Stage1 - Create ERD',
            status = "Done",
            date_created = date.today()
            ),
    
        Card(
            title='Eat a pie',
            description = 'Stage2 - have a snack',
            status = "In progress",
            date_created = date.today()
            ),
        Card(
        title='Marshmallow',
        description = 'Stage3 - have another snack',
        status = "In progress",
        date_created = date.today()
        )]
    # Execute session queue
    db.session.add_all(users)
    db.session.add_all(cards)
    db.session.commit()
    print("Database seeded")

# Drop tables command 
@db_commands.cli.command("clear_tables")
def drop_all():
    db.drop_all()
    print("Tables Dropped")

@db_commands.cli.command("all_cards")
def all_cards():
    #select * cards;
    # stmt = db.select(Card) # By default SELECT ALL unless specified
    # stmt is the SLQ statement generated by sqlalchemy
    # print(stmt) # -> SELECT cards.id, cards.title, cards.description, cards.date_created FROM cards

    # Execute statement:
    # cards = db.session.execute(stmt)
    # cards is an iterable object
    # print(cards) #-> <sqlalchemy.engine.result.ChunkedIteratorResult object at 0x7f6ccb5e9340>
    # print(cards.all()) #-> returns tuple (card object, columns selected)

    #Instead of execute call scalars ,will only return cards
    # cards = db.session.scalars(stmt)

    #print(cards) #-> [<Card 1>, <Card 2>, <Card 3>]
    # for card in cards:
    #     #print(card.__dict__)
    #     print(card.title)

    stmt = db.select(Card).limit(2)
    # If it's only 1 result we can use scalar to output string
    cards = db.session.scalars(stmt)    
    print(list(cards))

