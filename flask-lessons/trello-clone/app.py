from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from datetime import date
# Flask-Marshmallow
from flask_marshmallow import Marshmallow
# Bcrypt used to encrypt passwords
from flask_bcrypt import Bcrypt 
# SQL Alchemy 
from sqlalchemy.exc import IntegrityError
# JWT Token generator
from flask_jwt_extended import JWTManager, create_access_token, jwt_required

from datetime import timedelta


app = Flask(__name__)

# Insert DB connection string into app.config
app.config[
    'SQLALCHEMY_DATABASE_URI'
    ] = 'postgresql+psycopg2://trello_dev:charmander@127.0.0.1:5432/trello'
# Create JWT Token Secret Key
app.config['JWT_SECRET_KEY'] = 'Ministry of Truth'

# connect to database
db = SQLAlchemy(app)
ma = Marshmallow(app)
bcrypt = Bcrypt(app) 
jwt = JWTManager(app)

# declare model - default table name will be class name
class Card(db.Model):
    __tablename__ = 'cards'
    # make a Column (data Type, primary key)
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100))
    description = db.Column(db.Text())
    status = db.Column(db.String(100))
    date_created = db.Column(db.Date())

class CardSchema(ma.Schema):
    class Meta:
        fields = ("id", "title", "description", "status", "date_created")

class User(db.Model):
    __tablename__ = "users"

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String)
    email = db.Column(db.String, nullable=False, unique=True) # to specify NOT NULL we use nullable=False
    password = db.Column(db.String, nullable=False)
    is_admin = db.Column(db.Boolean, default=False)

class UserSchema(ma.Schema):
    class Meta:
        fields = ("id", "name", "email", "password", "is_admin")



# Create tables - make a terminal command - use flask db_create to run
@app.cli.command('db_create')
def db_create():
    db.drop_all()
    db.create_all()
    print('created tables')

# Seed database
@app.cli.command('db_seed')
def db_seed():
    # card1 = Card(
    #     title='Start the project',
    #     description = 'Stage1 - Create ERD',
    #     date_created = date.today()
    #     )
    # # Add to session queue
    # db.session.add(card1)

    # card2 = Card(
    #     title='Eat a pie',
    #     description = 'Stage2 - have a snack',
    #     date_created = date.today()
    #     )
    # # Add to session queue
    # db.session.add(card2)    

    # card3 = Card(
    # title='Marshmallow',
    # description = 'Stage3 - have another snack',
    # date_created = date.today()
    # )
    # # Add to session queue
    # db.session.add(card3)    

    users = [
        User(
            email="admin@spam.com",
            password=bcrypt.generate_password_hash("spinynorman").decode('utf8'),
            is_admin=True
        ),
        User(
            name="John Cleese",
            email="cleese@spam.com",
            password=bcrypt.generate_password_hash("tisbutascratch").decode('utf-8')
        )
    ]

    cards = [
        Card(
            title='Start the project',
            description = 'Stage1 - Create ERD',
            status = "Done",
            date_created = date.today()
            ),
    
        Card(
            title='Eat a pie',
            description = 'Stage2 - have a snack',
            status = "In progress",
            date_created = date.today()
            ),
        Card(
        title='Marshmallow',
        description = 'Stage3 - have another snack',
        status = "In progress",
        date_created = date.today()
        )]
    # Execute session queue
    db.session.add_all(users)
    db.session.add_all(cards)
    db.session.commit()
    print("Database seeded")

# Drop tables command 
@app.cli.command("db_clear_tables")
def drop_all():
    db.drop_all()
    print("Tables Dropped")

@app.cli.command("all_cards")
def all_cards():
    #select * cards;
    # stmt = db.select(Card) # By default SELECT ALL unless specified
    # stmt is the SLQ statement generated by sqlalchemy
    # print(stmt) # -> SELECT cards.id, cards.title, cards.description, cards.date_created FROM cards

    # Execute statement:
    # cards = db.session.execute(stmt)
    # cards is an iterable object
    # print(cards) #-> <sqlalchemy.engine.result.ChunkedIteratorResult object at 0x7f6ccb5e9340>
    # print(cards.all()) #-> returns tuple (card object, columns selected)

    #Instead of execute call scalars ,will only return cards
    # cards = db.session.scalars(stmt)

    #print(cards) #-> [<Card 1>, <Card 2>, <Card 3>]
    # for card in cards:
    #     #print(card.__dict__)
    #     print(card.title)

    stmt = db.select(Card).limit(2)
    # If it's only 1 result we can use scalar to output string
    cards = db.session.scalars(stmt)    
    print(list(cards))


#------------------------ROUTES ----------------|
# we use /users/register as the path needs to be a resource type / element 
@app.route('/users/register', methods=["POST"])
def register():
    try:
        # Parse incoming POST body through schema
        user_info = UserSchema(exclude=['id']).load(request.json) 
        # UserSchema validates the request.json against the fields in the schema
        # NOTE: we exclude id from the schema as this is autogenerated

        # Create new user with the parsed data
        user = User(
            email=user_info['email'],
            password=bcrypt.generate_password_hash(user_info['password']).decode('utf8'),
            name=user_info.get('name', "")
        )
        # print(user.__dict__)

        # Add and commit the new user to the database
        db.session.add(user)
        db.session.commit()
        # print(user_info)
        # print(request.json) # request object contains all the information about the incoming request

        #return the new user with 201 code
        return UserSchema(exclude=['password']).dump(user), 201
    
    except IntegrityError:
        return {"error" : "Email address already in use"}, 409

@app.route('/users/login', methods=["POST"])
def users_login():
    # 1. PArse incoming POST body through the ma schema
    user_info = UserSchema(exclude=['id', 'name','is_admin']).load(request.json) 
    print(user_info)

    # 2. Select user with email  that matches one in the POST body
    stmt = db.select(User).where(User.email == user_info['email']) #, User.password == bcrypt.generate_password_hash(user_info["password"]).decode('utf8'))
    user = db.session.scalar(stmt)

    # 3. Check Email exists & verify password hash
    if user and bcrypt.check_password_hash(user.password, user_info["password"]):
        # 4. Create JWT token
        token = create_access_token(identity=user.email, expires_delta=timedelta(hours=2)) # can add additional claims, additional_claims={'email' : user.email, 'name' : user.name})
        # 5 return Token
        return {'token': token, 'user': UserSchema(exclude=['password']).dump(user)}, 200
    else:
        return {"Error": "Invalid username or password"}, 401



    # 5 return Token
  

@app.cli.command("some_cards")
def some_cards():
    stmt = db.select(Card).where(db.or_(Card.id < 2, Card.status != "Done")).order_by(Card.title.desc())
    # OR: where(db.or_(card.id > 2, Card.status != "Done"))
    # AND: where(card.id > 2, Card.status != "Done")
    cards = db.session.scalars(stmt)
    for card in cards:
        print(card.title)
    print(CardSchema(many=True).dump(cards))

# Test to make sure we are connecting
@app.route('/')
def index():
    return ['Hello World!']

@app.route("/cards")
@jwt_required()
def all_the_cards():
    stmt = db.select(Card)
    cards = db.session.scalars(stmt) #.all()
    print(cards)
    # dumps returns string, dump return list of dicts
    return CardSchema(many=True).dump(cards)

# ------------------------Error Handler --------------

# @app.errorhandler(IntegrityError)
# def integrity_error(err):
#     # print(err)
#     print((err.__dict__))
#     return {"error": str(err)}